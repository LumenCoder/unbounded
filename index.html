<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Cosmic Inspiration Blog</title>
  <style>
    /* Base Reset & Global Styles */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      background: linear-gradient(45deg, #000, #300);
      color: #fff;
      font-family: Arial, sans-serif;
      overflow-x: hidden;
      scroll-behavior: smooth;
    }
    /* Three.js canvas placed behind everything */
    canvas {
      position: fixed;
      top: 0;
      left: 0;
      z-index: -2;
    }
    .section {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      padding: 1.5rem;
    }
    h1 {
      font-size: 4rem;
      text-transform: uppercase;
      letter-spacing: 0.5rem;
    }
    p {
      font-size: 1.5rem;
      max-width: 800px;
      margin: 0 auto;
    }
    /* “Dud” characters in glitch effect */
    .dud {
      opacity: 0.5;
      color: #ff5555;
    }
    .blog-content {
      max-width: 800px;
      margin: 0 auto;
      text-align: left;
      padding: 1.5rem;
      line-height: 1.6;
    }
    .blog-content p {
      font-size: 1.2rem;
      margin-bottom: 2rem;
    }
    .blog-content strong {
      font-weight: bold;
      color: #ff5555;
      font-size: 1.8rem;
      display: block;
      margin-bottom: 0.5rem;
    }
    /* Each blog post is clickable */
    .blog-post {
      cursor: pointer;
      transition: transform 0.3s ease;
    }
    .blog-post:hover {
      transform: scale(1.02);
    }
    /* Animated Down Arrows */
    #scrollArrows {
      margin-top: 20px;
      display: flex;
      flex-direction: column;
      gap: 5px;
      align-items: center;
    }
    .arrow {
      width: 20px;
      height: 20px;
      border: solid black;
      border-width: 0 3px 3px 0;
      transform: rotate(45deg);
      animation: arrowPulse 2s infinite;
    }
    @keyframes arrowPulse {
      0%   { border-color: black; }
      50%  { border-color: darkred; }
      100% { border-color: black; }
    }
    /* Final Button Section (at the bottom as before) */
    #finalSection {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      padding: 1.5rem;
    }
    #endButton {
      padding: 25px 50px;
      font-size: 2.5rem;
      color: #fff;
      background: linear-gradient(45deg, #ff0000, #ff5555);
      border: none;
      border-radius: 10px;
      cursor: pointer;
      box-shadow: 0 0 30px rgba(255, 0, 0, 0.8);
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }
    #endButton:hover {
      transform: scale(1.05);
      box-shadow: 0 0 60px rgba(255, 0, 0, 1);
    }
    /* End Credits */
    #endCredits {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #000;
      color: #fff;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      z-index: 10;
    }
    #endCredits p {
      font-size: 2.5rem;
      margin: 10px 0;
      opacity: 0;
    }
    /* Nova Explosion Effect */
    #nova {
      position: absolute;
      width: 50px;
      height: 50px;
      background: radial-gradient(circle, #fff, rgba(255,255,255,0));
      border-radius: 50%;
      pointer-events: none;
      opacity: 0;
      z-index: 11;
    }
  </style>
</head>
<body>
  <!-- Vertex Shader -->
  <script id="vertexShader" type="x-shader/x-vertex">
    varying vec2 vUv;
    void main(){
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
    }
  </script>
  <!-- Fragment Shader (with fluid offset and animated base color) -->
  <script id="fragmentShader" type="x-shader/x-fragment">
    uniform float u_time;
    uniform vec2 u_resolution;
    uniform vec3 u_baseColor;
    varying vec2 vUv;
    
    float random(in vec2 st) {
      return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
    }
    float noise(in vec2 st) {
      vec2 i = floor(st);
      vec2 f = fract(st);
      float a = random(i);
      float b = random(i + vec2(1.0, 0.0));
      float c = random(i + vec2(0.0, 1.0));
      float d = random(i + vec2(1.0, 1.0));
      vec2 u = f*f*(3.0-2.0*f);
      return mix(a, b, u.x) +
             (c - a) * u.y * (1.0 - u.x) +
             (d - b) * u.x * u.y;
    }
    void main(){
      vec2 st = gl_FragCoord.xy / u_resolution.xy;
      vec2 pos = (st - 0.5) * 3.0;
      pos += 0.1 * vec2(sin(u_time * 0.5), cos(u_time * 0.5));
      float r = length(pos);
      float angle = atan(pos.y, pos.x);
      angle += 0.5 * sin(u_time + r * 10.0);
      vec2 uv = vec2(r * cos(angle), r * sin(angle));
      float n = noise(uv * 5.0 + u_time * 0.2);
      vec3 color = mix(vec3(0.0), u_baseColor, n);
      color += (1.0 - smoothstep(0.0, 0.5, r)) * vec3(0.2, 0.0, 0.0);
      gl_FragColor = vec4(color, 1.0);
    }
  </script>
  
  <!-- Main Content -->
  <div id="mainContent">
    <!-- Section 1: Header & Animated Arrows -->
    <div class="section" id="section1">
      <h1 id="text1">Welcome to the Cosmic Journey</h1>
      <div id="scrollArrows">
        <div class="arrow"></div>
        <div class="arrow"></div>
        <div class="arrow"></div>
      </div>
    </div>
    <!-- Section 2 -->
    <div class="section" id="section2">
      <p id="text2">Explore the unknown, transcend boundaries, and awaken your inner universe.</p>
    </div>
    <!-- Section 3 -->
    <div class="section" id="section3">
      <h1 id="text3">Embrace the Future</h1>
    </div>
    <!-- Section 4 -->
    <div class="section" id="section4">
      <p id="text4">Let each moment inspire you to create, innovate, and dream without limits.</p>
    </div>
    <!-- Blog Section -->
    <div class="section" id="sectionBlog">
      <div class="blog-content">
        <p id="blogText1">
          Our written code defines both present and future outcomes<br>
          Programming consists of more than simple code writing because it represents creative art alongside innovative heartbeats which establish the base of digital reality. Technological evolution meets a high standard of obligation because programmers handle these new difficulties that emerge in their trade.
        </p>
        <!-- Five clickable blog posts -->
        <div class="blog-post" id="post1">
          <p id="blogText2">
            <strong>1. AI in Coding: Evolution or Extinction?</strong>
            Artificial intelligence exists today to write software code and repair program flaws while making continuous self-optimizations. The efficiency claims of GitHub Copilot generate concerns about whether developers receive empowerment or face replacement. The training process of AI models on open-source code generates ethical issues regarding intellectual property rights and bias-related problems. The future of coding exists in the way programmers learn to control AI technology rather than in AI taking over programming responsibilities.
          </p>
        </div>
        <div class="blog-post" id="post2">
          <p id="blogText3">
            <strong>2. The digital realm exists because of cybersecurity which operates through protective computer codes.</strong>
            Every keystroke has consequences. An individual vulnerability has the power to endanger millions of people from cyberattacks. Secure code writing stands as a mandatory responsibility because data functions as digital currency in present-day society. Quantum computing technology now poses a threat to all encryption methods which compels developers to create new security approaches. The ongoing battle between defenders and hackers continues indefinitely so the most effective tool we possess comes from our acquired understanding.
          </p>
        </div>
        <div class="blog-post" id="post3">
          <p id="blogText4">
            <strong>3. Open-Source vs. Proprietary: Freedom or Control?</strong>
            A group of people hold the belief that code must exist as a free resource which advances human progress. The development of software requires both financial support and organizational structure as well as exclusive control to achieve significant advancements. Both difference-making open-source projects and the world-changing powerful technologies are controlled by corporate interests although their development comes from open-source programming. The world will be shaped by which force emerges victorious.
          </p>
        </div>
        <div class="blog-post" id="post4">
          <p id="blogText5">
            <strong>4. Low-Code & No-Code: A Gateway or a Gimmick?</strong>
            Software development becomes possible without writing code. Thousands now can develop applications through low-code and no-code software platforms yet developers question the effectiveness of fundamental development practices. The tools reduce boundaries but genuine innovation needs people who grasp the inner workings to achieve it. Programmers will evolve into architectural designers instead of software construction specialists.
          </p>
        </div>
        <div class="blog-post" id="post5">
          <p id="blogText6">
            <strong>5. Software Bloat: The Silent Killer of Performance</strong>
            Modern applications consume excessive power for what reason? The excess software code diminishes hardware capabilities by negatively affecting processing time alongside causing increased user ineffectiveness. Coding with minimalism serves three essential purposes: it demonstrates hardware respect as well as user-friendly design principles and sustainable development practices. Optimization functions as a fundamental mindset which distinguishes skillful developers from superior ones.
          </p>
        </div>
        <p id="blogText7">
          <strong>The Code We Leave Behind</strong>
          Our written functions together with all our daily decisions will determine the digital landscape of the future. Current solution-based approaches define the user experiences which future generations will encounter. Programming functions as both skill and time-tested inheritance system. What we build stands as the essential aspect of development.
        </p>
        <p id="blogText8">
          The question focuses on which type of world we intend to build.
        </p>
      </div>
    </div>
    <!-- Final Button Section -->
    <div class="section" id="finalSection">
      <button id="endButton">let the code end</button>
    </div>
  </div>
  
  <!-- End Credits Container -->
  <div id="endCredits">
    <p id="credit1">code is infinite</p>
    <p id="credit2">made with love</p>
    <p id="credit3">Lumen</p>
    <div id="nova"></div>
  </div>
  
  <!-- GSAP and Three.js Libraries -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollTrigger.min.js"></script>
  
  <script>
    // Register ScrollTrigger plugin
    gsap.registerPlugin(ScrollTrigger);
    
    // Initialize Cosmic Background
    let shaderMaterial;
    function initBackground() {
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 1, 3000);
      camera.position.z = 400;
      const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
      
      // Create a large plane using our custom shader (fluid nebula)
      const planeGeometry = new THREE.PlaneGeometry(1000, 1000);
      shaderMaterial = new THREE.ShaderMaterial({
        uniforms: {
          u_time: { value: 0 },
          u_resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
          u_baseColor: { value: new THREE.Color(0.6, 0.0, 0.0) } // starts as red
        },
        vertexShader: document.getElementById('vertexShader').textContent,
        fragmentShader: document.getElementById('fragmentShader').textContent,
        depthWrite: false
      });
      const plane = new THREE.Mesh(planeGeometry, shaderMaterial);
      plane.position.z = -600;
      scene.add(plane);
      
      // Particle system for extra cosmic sparkle
      const particleCount = 1500;
      const geometry = new THREE.BufferGeometry();
      const positions = [];
      const colors = [];
      const color = new THREE.Color();
      for (let i = 0; i < particleCount; i++) {
        positions.push((Math.random() * 2 - 1) * 1000);
        positions.push((Math.random() * 2 - 1) * 1000);
        positions.push((Math.random() * 2 - 1) * 1000);
        color.setHSL(0, 1, 0.5 + Math.random() * 0.1);
        colors.push(color.r, color.g, color.b);
      }
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
      const material = new THREE.PointsMaterial({ size: 2, vertexColors: true });
      const particles = new THREE.Points(geometry, material);
      scene.add(particles);
      
      function animate() {
        requestAnimationFrame(animate);
        shaderMaterial.uniforms.u_time.value = performance.now() / 1000;
        particles.rotation.y += 0.0005;
        renderer.render(scene, camera);
      }
      animate();
      
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        shaderMaterial.uniforms.u_resolution.value.set(window.innerWidth, window.innerHeight);
      });
    }
    initBackground();
    
    // TextScramble Class for Glitch Effect
    class TextScramble {
      constructor(el) {
        this.el = el;
        this.chars = '!<>-_\\/[]{}—=+*^?#________';
        this.update = this.update.bind(this);
      }
      setText(newText) {
        const oldText = this.el.innerText;
        const length = Math.max(oldText.length, newText.length);
        const promise = new Promise((resolve) => this.resolve = resolve);
        this.queue = [];
        for (let i = 0; i < length; i++) {
          const from = oldText[i] || '';
          const to = newText[i] || '';
          const start = Math.floor(Math.random() * 20);
          const end = start + Math.floor(Math.random() * 20);
          this.queue.push({ from, to, start, end, char: '' });
        }
        cancelAnimationFrame(this.frameRequest);
        this.frame = 0;
        this.update();
        return promise;
      }
      update() {
        let output = '';
        let complete = 0;
        for (let i = 0; i < this.queue.length; i++) {
          let { from, to, start, end, char } = this.queue[i];
          if (this.frame >= end) {
            complete++;
            output += to;
          } else if (this.frame >= start) {
            if (!char || Math.random() < 0.28) {
              char = this.randomChar();
              this.queue[i].char = char;
            }
            output += `<span class="dud">${char}</span>`;
          } else {
            output += from;
          }
        }
        this.el.innerHTML = output;
        if (complete === this.queue.length) {
          this.resolve();
        } else {
          this.frameRequest = requestAnimationFrame(this.update);
          this.frame++;
        }
      }
      randomChar() {
        return this.chars[Math.floor(Math.random() * this.chars.length)];
      }
    }
    
    // Scroll-Triggered Text Animations (with glitch effect)
    function initTextAnimations() {
      const texts = [
        { id: 'text1', newText: 'Welcome to the Cosmic Journey' },
        { id: 'text2', newText: 'Explore the unknown, transcend boundaries, and awaken your inner universe.' },
        { id: 'text3', newText: 'Embrace the Future' },
        { id: 'text4', newText: 'Let each moment inspire you to create, innovate, and dream without limits.' }
      ];
      texts.forEach(item => {
        const el = document.getElementById(item.id);
        const scramble = new TextScramble(el);
        ScrollTrigger.create({
          trigger: '#' + item.id,
          start: 'top 80%',
          onEnter: () => {
            scramble.setText(item.newText);
            gsap.from