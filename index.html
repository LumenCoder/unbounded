<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Cosmic Inspiration Blog</title>
  <style>
    /* Base Reset & Global Styles */
    html, body {
      margin: 0;
      padding: 0;
      /* Fallback fluid gradient in case shader fails */
      background: linear-gradient(45deg, #000, #300);
      color: #fff;
      font-family: 'Arial', sans-serif;
      overflow-x: hidden;
      scroll-behavior: smooth;
    }
    /* Hide text initially to avoid FOUC */
    h1, p, .blog-content p {
      opacity: 0;
    }
    /* Three.js canvas behind everything */
    canvas {
      position: fixed;
      top: 0;
      left: 0;
      z-index: -2;
    }
    /* Section Styling */
    .section {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      padding: 1.5rem;
    }
    h1 {
      font-size: 4rem;
      margin: 0;
      text-transform: uppercase;
      letter-spacing: 0.5rem;
    }
    p {
      font-size: 1.5rem;
      max-width: 800px;
      margin: 0 auto;
    }
    .dud {
      opacity: 0.5;
      color: #ff5555;
    }
    /* Blog Content Styling */
    .blog-content {
      max-width: 800px;
      margin: 0 auto;
      text-align: left;
      padding: 1.5rem;
      line-height: 1.6;
    }
    .blog-content p {
      font-size: 1.2rem;
      margin-bottom: 2rem;
    }
    .blog-content strong {
      font-weight: bold;
      color: #ff5555;
      font-size: 1.8rem;
      display: block;
      margin-bottom: 0.5rem;
    }
    /* Wrap numbered posts in clickable containers */
    .blog-post {
      cursor: pointer;
      transition: transform 0.3s ease;
    }
    .blog-post:hover {
      transform: scale(1.02);
    }
    /* Scroll Arrows (placed below Section1 header) */
    #scrollArrows {
      margin-top: 20px;
      display: flex;
      flex-direction: column;
      gap: 5px;
      align-items: center;
    }
    .arrow {
      width: 20px;
      height: 20px;
      border: solid black;
      border-width: 0 3px 3px 0;
      transform: rotate(45deg);
      animation: arrowPulse 2s infinite;
    }
    @keyframes arrowPulse {
      0%   { border-color: black; }
      50%  { border-color: darkred; }
      100% { border-color: black; }
    }
    /* Final Button – reverted to its original placement */
    #finalSection {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      padding: 1.5rem;
    }
    #endButton {
      padding: 25px 50px;
      font-size: 2.5rem;
      color: #fff;
      background: linear-gradient(45deg, #ff0000, #ff5555);
      border: none;
      border-radius: 10px;
      cursor: pointer;
      box-shadow: 0 0 30px rgba(255, 0, 0, 0.8);
      transition: all 0.3s ease;
    }
    #endButton:hover {
      transform: scale(1.05);
      box-shadow: 0 0 60px rgba(255, 0, 0, 1);
    }
    /* End Credits Styling (unchanged) */
    #endCredits {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #000;
      color: #fff;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      z-index: 10;
    }
    #endCredits p {
      font-size: 2.5rem;
      margin: 10px 0;
      opacity: 0;
    }
    /* Nova effect for explosion finale */
    #nova {
      position: absolute;
      width: 50px;
      height: 50px;
      background: radial-gradient(circle, #fff, rgba(255,255,255,0));
      border-radius: 50%;
      pointer-events: none;
      opacity: 0;
      z-index: 11;
    }
  </style>
</head>
<body>
  <!-- Vertex Shader for Cosmic Background -->
  <script id="vertexShader" type="x-shader/x-vertex">
    varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  </script>
  <!-- Fragment Shader for Cosmic Background with fluid offset and a uniform base color -->
  <script id="fragmentShader" type="x-shader/x-fragment">
    uniform float u_time;
    uniform vec2 u_resolution;
    uniform vec3 u_baseColor;
    varying vec2 vUv;
    
    float random (in vec2 st) {
      return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
    }
    float noise (in vec2 st) {
      vec2 i = floor(st);
      vec2 f = fract(st);
      float a = random(i);
      float b = random(i + vec2(1.0, 0.0));
      float c = random(i + vec2(0.0, 1.0));
      float d = random(i + vec2(1.0, 1.0));
      vec2 u = f*f*(3.0-2.0*f);
      return mix(a, b, u.x) +
             (c - a)* u.y * (1.0 - u.x) +
             (d - b) * u.x * u.y;
    }
    void main() {
      vec2 st = gl_FragCoord.xy / u_resolution.xy;
      vec2 pos = (st - 0.5) * 3.0;
      // Add a fluid offset for extra motion
      pos += 0.1 * vec2(sin(u_time * 0.5), cos(u_time * 0.5));
      float r = length(pos);
      float angle = atan(pos.y, pos.x);
      angle += 0.5 * sin(u_time + r * 10.0);
      vec2 uv = vec2(r * cos(angle), r * sin(angle));
      float n = noise(uv * 5.0 + u_time * 0.2);
      // Use u_baseColor so we can animate the background color change
      vec3 color = mix(vec3(0.0), u_baseColor, n);
      color += (1.0 - smoothstep(0.0, 0.5, r)) * vec3(0.2, 0.0, 0.0);
      gl_FragColor = vec4(color, 1.0);
    }
  </script>
  
  <!-- Main Content Container -->
  <div id="mainContent">
    <!-- Section1: Header + Animated Down Arrows -->
    <div class="section" id="section1">
      <h1 id="text1">Welcome to the Cosmic Journey</h1>
      <div id="scrollArrows">
        <div class="arrow"></div>
        <div class="arrow"></div>
        <div class="arrow"></div>
      </div>
    </div>
    <!-- Other Intro Sections -->
    <div class="section" id="section2">
      <p id="text2">Explore the unknown, transcend boundaries, and awaken your inner universe.</p>
    </div>
    <div class="section" id="section3">
      <h1 id="text3">Embrace the Future</h1>
    </div>
    <div class="section" id="section4">
      <p id="text4">Let each moment inspire you to create, innovate, and dream without limits.</p>
    </div>
    <!-- Blog Content Section -->
    <div class="section" id="sectionBlog">
      <div class="blog-content">
        <p id="blogText1">
          Our written code defines both present and future outcomes<br>
          Programming consists of more than simple code writing because it represents creative art alongside innovative heartbeats which establish the base of digital reality. Technological evolution meets a high standard of obligation because programmers handle these new difficulties that emerge in their trade.
        </p>
        <!-- Each numbered blog post is now in its own clickable container -->
        <div class="blog-post" id="post1">
          <p id="blogText2">
            <strong>1. AI in Coding: Evolution or Extinction?</strong>
            Artificial intelligence exists today to write software code and repair program flaws while making continuous self-optimizations. The efficiency claims of GitHub Copilot generate concerns about whether developers receive empowerment or face replacement. The training process of AI models on open-source code generates ethical issues regarding intellectual property rights and bias-related problems. The future of coding exists in the way programmers learn to control AI technology rather than in AI taking over programming responsibilities.
          </p>
        </div>
        <div class="blog-post" id="post2">
          <p id="blogText3">
            <strong>2. The digital realm exists because of cybersecurity which operates through protective computer codes.</strong>
            Every keystroke has consequences. An individual vulnerability has the power to endanger millions of people from cyberattacks. Secure code writing stands as a mandatory responsibility because data functions as digital currency in present-day society. Quantum computing technology now poses a threat to all encryption methods which compels developers to create new security approaches. The ongoing battle between defenders and hackers continues indefinitely so the most effective tool we possess comes from our acquired understanding.
          </p>
        </div>
        <div class="blog-post" id="post3">
          <p id="blogText4">
            <strong>3. Open-Source vs. Proprietary: Freedom or Control?</strong>
            A group of people hold the belief that code must exist as a free resource which advances human progress. The development of software requires both financial support and organizational structure as well as exclusive control to achieve significant advancements. Both difference-making open-source projects and the world-changing powerful technologies are controlled by corporate interests although their development comes from open-source programming. The world will be shaped by which force emerges victorious.
          </p>
        </div>
        <div class="blog-post" id="post4">
          <p id="blogText5">
            <strong>4. Low-Code & No-Code: A Gateway or a Gimmick?</strong>
            Software development becomes possible without writing code. Thousands now can develop applications through low-code and no-code software platforms yet developers question the effectiveness of fundamental development practices. The tools reduce boundaries but genuine innovation needs people who grasp the inner workings to achieve it. Programmers will evolve into architectural designers instead of software construction specialists.
          </p>
        </div>
        <div class="blog-post" id="post5">
          <p id="blogText6">
            <strong>5. Software Bloat: The Silent Killer of Performance</strong>
            Modern applications consume excessive power for what reason? The excess software code diminishes hardware capabilities by negatively affecting processing time alongside causing increased user ineffectiveness. Coding with minimalism serves three essential purposes: it demonstrates hardware respect as well as user-friendly design principles and sustainable development practices. Optimization functions as a fundamental mindset which distinguishes skillful developers from superior ones.
          </p>
        </div>
        <p id="blogText7">
          <strong>The Code We Leave Behind</strong>
          Our written functions together with all our daily decisions will determine the digital landscape of the future. Current solution-based approaches define the user experiences which future generations will encounter. Programming functions as both skill and time-tested inheritance system. What we build stands as the essential aspect of development.
        </p>
        <p id="blogText8">
          The question focuses on which type of world we intend to build.
        </p>
      </div>
    </div>
    <!-- Final Button Section (unchanged from previous version) -->
    <div class="section" id="finalSection">
      <button id="endButton">let the code end</button>
    </div>
  </div>
  
  <!-- End Credits Container (unchanged) -->
  <div id="endCredits">
    <p id="credit1">code is infinite</p>
    <p id="credit2">made with love</p>
    <p id="credit3">Lumen</p>
    <div id="nova"></div>
  </div>
  
  <!-- Include Three.js and GSAP Libraries -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollTrigger.min.js"></script>
  
  <script>
    /* Initialize Cosmic Background with Enhanced Shader & Particles */
    let shaderMaterial; // make shaderMaterial global so we can animate its uniform
    function initBackground() {
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 1, 3000);
      camera.position.z = 400;
      
      const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
      
      // Create a large plane with our custom shader for a fluid nebula effect
      const planeGeometry = new THREE.PlaneGeometry(1000, 1000);
      shaderMaterial = new THREE.ShaderMaterial({
        uniforms: {
          u_time: { value: 0 },
          u_resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
          u_baseColor: { value: new THREE.Color(0.6, 0.0, 0.0) } // initial red
        },
        vertexShader: document.getElementById('vertexShader').textContent,
        fragmentShader: document.getElementById('fragmentShader').textContent,
        depthWrite: false
      });
      const plane = new THREE.Mesh(planeGeometry, shaderMaterial);
      plane.position.z = -600;
      scene.add(plane);
      
      // Particle system for extra cosmic sparkle
      const particleCount = 1500;
      const geometry = new THREE.BufferGeometry();
      const positions = [];
      const colors = [];
      const color = new THREE.Color();
      
      for(let i = 0; i < particleCount; i++) {
        positions.push((Math.random() * 2 - 1) * 1000);
        positions.push((Math.random() * 2 - 1) * 1000);
        positions.push((Math.random() * 2 - 1) * 1000);
        color.setHSL(0, 1, 0.5 + Math.random() * 0.1);
        colors.push(color.r, color.g, color.b);
      }
      
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
      
      const material = new THREE.PointsMaterial({ size: 2, vertexColors: true });
      const particles = new THREE.Points(geometry, material);
      scene.add(particles);
      
      function animate() {
        requestAnimationFrame(animate);
        shaderMaterial.uniforms.u_time.value = performance.now() / 1000;
        particles.rotation.y += 0.0005;
        renderer.render(scene, camera);
      }
      animate();
      
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        shaderMaterial.uniforms.u_resolution.value.set(window.innerWidth, window.innerHeight);
      });
    }
    initBackground();
    
    /* TextScramble Class for Animated Text Effects (unchanged) */
    class TextScramble {
      constructor(el) {
        this.el = el;
        this.chars = '!<>-_\\/[]{}—=+*^?#________';
        this.update = this.update.bind(this);
      }
      setText(newText) {
        const oldText = this.el.innerText;
        const length = Math.max(oldText.length, newText.length);
        const promise = new Promise((resolve) => this.resolve = resolve);
        this.queue = [];
        for (let i = 0; i < length; i++) {
          const from = oldText[i] || '';
          const to = newText[i] || '';
          const start = Math.floor(Math.random() * 20);
          const end = start + Math.floor(Math.random() * 20);
          this.queue.push({ from, to, start, end, char: '' });
        }
        cancelAnimationFrame(this.frameRequest);
        this.frame = 0;
        this.update();
        return promise;
      }
      update() {
        let output = '';
        let complete = 0;
        for (let i = 0; i < this.queue.length; i++) {
          let { from, to, start, end, char } = this.queue[i];
          if (this.frame >= end) {
            complete++;
            output += to;
          } else if (this.frame >= start) {
            if (!char || Math.random() < 0.28) {
              char = this.randomChar();
              this.queue[i].char = char;
            }
            output += `<span class="dud">${char}</span>`;
          } else {
            output += from;
          }
        }
        this.el.innerHTML = output;
        if (complete === this.queue.length) {
          this.resolve();
        } else {
          this.frameRequest = requestAnimationFrame(this.update);
          this.frame++;
        }
      }
      randomChar() {
        return this.chars[Math.floor(Math.random() * this.chars.length)];
      }
    }
    
    /* GSAP Scroll-Triggered Animations for Intro & Blog Text */
    function initTextAnimations() {
      const texts = [
        { id: 'text1', newText: 'Welcome to the Cosmic Journey' },
        { id: 'text2', newText: 'Explore the unknown, transcend boundaries, and awaken your inner universe.' },
        { id: 'text3', newText: 'Embrace the Future' },
        { id: 'text4', newText: 'Let each moment inspire you to create, innovate, and dream without limits.' },
      ];
      
      texts.forEach(item => {
        const el = document.getElementById(item.id);
        const scramble = new TextScramble(el);
        ScrollTrigger.create({
          trigger: '#' + item.id,
          start: 'top 80%',
          onEnter: () => {
            scramble.setText(item.newText);
            gsap.fromTo(el, 
              { opacity: 0, scale: 0.8, skewX: 20 }, 
              { opacity: 1, scale: 1, skewX: 0, duration: 0.7, ease: "back.out(2)" }
            );
          },
          onEnterBack: () => {
            scramble.setText(item.newText);
            gsap.fromTo(el, 
              { opacity: 0, scale: 0.8, skewX: 20 }, 
              { opacity: 1, scale: 1, skewX: 0, duration: 0.7, ease: "back.out(2)" }
            );
          }
        });
      });
    }
    initTextAnimations();
    
    function initBlogAnimations() {
      const blogPosts = document.querySelectorAll('.blog-post');
      blogPosts.forEach(post => {
        post.addEventListener('click', () => {
          // Animate background color change: animate u_baseColor from red to dark grey
          gsap.to(shaderMaterial.uniforms.u_baseColor.value, {
            r: 0.13,
            g: 0.13,
            b: 0.13,
            duration: 1,
            ease: "power2.inOut",
            onUpdate: () => {
              shaderMaterial.uniforms.u_baseColor.needsUpdate = true;
            }
          });
          // Fade out all other blog posts with glitch effect (using our TextScramble)
          blogPosts.forEach(otherPost => {
            if(otherPost !== post){
              gsap.to(otherPost, { opacity: 0, duration: 0.7, ease: "power2.in" });
            }
          });
          // Expand the clicked post with a glitch reveal
          const scramble = new TextScramble(post.querySelector('p'));
          scramble.setText(post.querySelector('p').textContent);
          gsap.to(post, { 
            scale: 1.05, 
            duration: 0.7, 
            ease: "back.out(2)",
            onComplete: () => {
              // Optionally, remove the glitch effect after expansion.
            }
          });
        });
      });
    }
    initBlogAnimations();
    
    /* Final Button (unchanged from before) */
    const endButton = document.getElementById("endButton");
    endButton.addEventListener("mouseenter", () => {
      endButton.textContent = "set me free";
    });
    endButton.addEventListener("mouseleave", () => {
      endButton.textContent = "let the code end";
    });
    
    endButton.addEventListener("click", () => {
      const tl = gsap.timeline();
      // Suck in effect: scale down main content toward the button’s location while the button remains in place
      tl.to("#mainContent", {
        duration: 1, 
        scale: 0, 
        transformOrigin: "center center",
        ease: "power2.inOut"
      }, 0);
      // Fade out the background (canvas)
      tl.to("canvas", {
        duration: 1, 
        opacity: 0,
        ease: "power2.inOut"
      }, 0);
      // Delay then show end credits